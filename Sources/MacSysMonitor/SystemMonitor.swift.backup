import Foundation
import Combine
import AppKit

struct MetricsSample: Identifiable {
    let id = UUID()
    let timestamp: Date

    // CPU
    let cpuUsage: Double
    let cpuSystem: Double
    let cpuUser: Double
    let cpuIdle: Double

    // メモリ
    let memoryUsage: Double
    let memoryUsedMB: Double
    let memoryFreeMB: Double
    let memoryPressure: Double
    let memoryApp: Double
    let memoryWired: Double
    let memoryCompressed: Double

    // ネットワーク
    let uploadMbps: Double
    let downloadMbps: Double
    let localIP: String

    // ストレージ
    let storageUsedGB: Double
    let storageTotalGB: Double
    let storageUsage: Double

    // バッテリー
    let batteryLevel: Double
    let batteryIsCharging: Bool
    let batteryCapacity: Double
    let batteryCycleCount: Int
    let batteryTemperature: Double
}

struct NetworkCounters {
    var inbound: UInt64
    var outbound: UInt64
}

final class SystemMonitor: ObservableObject {
    @Published private(set) var samples: [MetricsSample] = []
    @Published var settings = MonitorSettings()

    private var timer: AnyCancellable?
    private var previousCPULoad: host_cpu_load_info?
    private var previousNetwork: NetworkCounters?
    private var previousNetworkDate: Date?

    let maxSamples = 120
    let totalMemoryMB = Double(ProcessInfo.processInfo.physicalMemory) / (1024 * 1024)

    init() {
        refresh()
        startTimer()
    }

    deinit {
        timer?.cancel()
    }

    var latest: MetricsSample? { samples.last }

    func startTimer() {
        timer?.cancel()
        timer = Timer.publish(every: settings.updateInterval, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                self?.refresh()
            }
    }

    func refresh() {
        let now = Date()
        let cpu = cpuUsage() ?? 0
        let memory = memoryUsage()
        let net = networkUsage(at: now)

        let sample = MetricsSample(
            timestamp: now,
            cpuUsage: cpu,
            memoryUsage: memory.percent,
            memoryUsedMB: memory.usedMB,
            memoryFreeMB: memory.freeMB,
            uploadMbps: net.uploadMbps,
            downloadMbps: net.downloadMbps
        )

        samples.append(sample)
        if samples.count > maxSamples {
            samples.removeFirst(samples.count - maxSamples)
        }
    }

    private func cpuUsage() -> Double? {
        var count = mach_msg_type_number_t(MemoryLayout<host_cpu_load_info_data_t>.stride / MemoryLayout<integer_t>.stride)
        var info = host_cpu_load_info()

        let result = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: Int(count)) {
                host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, $0, &count)
            }
        }

        guard result == KERN_SUCCESS else { return nil }

        let user = Double(info.cpu_ticks.0)
        let system = Double(info.cpu_ticks.1)
        let idle = Double(info.cpu_ticks.2)
        let nice = Double(info.cpu_ticks.3)

        let totalTicks = user + system + idle + nice
        let usedTicks = user + system + nice

        if let previous = previousCPULoad {
            let prevUser = Double(previous.cpu_ticks.0)
            let prevSystem = Double(previous.cpu_ticks.1)
            let prevIdle = Double(previous.cpu_ticks.2)
            let prevNice = Double(previous.cpu_ticks.3)

            let prevTotal = prevUser + prevSystem + prevIdle + prevNice
            let prevUsed = prevUser + prevSystem + prevNice

            let deltaTotal = totalTicks - prevTotal
            let deltaUsed = usedTicks - prevUsed
            previousCPULoad = info

            guard deltaTotal > 0 else { return nil }
            return max(0, min(100, (deltaUsed / deltaTotal) * 100))
        } else {
            previousCPULoad = info
            return nil
        }
    }

    private func memoryUsage() -> (percent: Double, usedMB: Double, freeMB: Double) {
        var size = mach_msg_type_number_t(MemoryLayout<vm_statistics64_data_t>.size) / 4
        var vmStats = vm_statistics64()

        let result = withUnsafeMutablePointer(to: &vmStats) {
            $0.withMemoryRebound(to: integer_t.self, capacity: Int(size)) {
                host_statistics64(mach_host_self(), HOST_VM_INFO64, $0, &size)
            }
        }

        guard result == KERN_SUCCESS else { return (0, 0, 0) }

        let pageSize = Double(vm_kernel_page_size)
        let free = Double(vmStats.free_count) * pageSize
        let active = Double(vmStats.active_count) * pageSize
        let inactive = Double(vmStats.inactive_count) * pageSize
        let wired = Double(vmStats.wire_count) * pageSize
        let compressed = Double(vmStats.compressor_page_count) * pageSize

        let used = active + inactive + wired + compressed
        let total = used + free

        let usedMB = used / (1024 * 1024)
        let freeMB = free / (1024 * 1024)
        let percent = total > 0 ? (used / total) * 100 : 0

        return (percent, usedMB, freeMB)
    }

    private func networkUsage(at date: Date) -> (uploadMbps: Double, downloadMbps: Double) {
        guard let counters = networkCounters() else { return (0, 0) }
        defer {
            previousNetwork = counters
            previousNetworkDate = date
        }

        guard let previousNetwork, let previousNetworkDate else { return (0, 0) }
        let deltaTime = date.timeIntervalSince(previousNetworkDate)
        guard deltaTime > 0 else { return (0, 0) }

        let deltaIn = Double(counters.inbound - previousNetwork.inbound)
        let deltaOut = Double(counters.outbound - previousNetwork.outbound)

        let downloadMbps = (deltaIn / deltaTime) / (1024 * 1024) * 8
        let uploadMbps = (deltaOut / deltaTime) / (1024 * 1024) * 8

        return (uploadMbps, downloadMbps)
    }

    private func networkCounters() -> NetworkCounters? {
        var interfaceAddresses: UnsafeMutablePointer<ifaddrs>?
        guard getifaddrs(&interfaceAddresses) == 0, let first = interfaceAddresses else { return nil }
        defer { freeifaddrs(interfaceAddresses) }

        var inbound: UInt64 = 0
        var outbound: UInt64 = 0

        for pointer in sequence(first: first, next: { $0.pointee.ifa_next }) {
            let interface = pointer.pointee
            let flags = Int32(interface.ifa_flags)
            let isUp = (flags & IFF_UP) == IFF_UP
            let isRunning = (flags & IFF_RUNNING) == IFF_RUNNING
            if !isUp || !isRunning { continue }

            let name = String(cString: interface.ifa_name)
            if name == "lo0" { continue }

            guard let data = interface.ifa_data?.assumingMemoryBound(to: if_data.self).pointee else { continue }
            inbound += UInt64(data.ifi_ibytes)
            outbound += UInt64(data.ifi_obytes)
        }

        return NetworkCounters(inbound: inbound, outbound: outbound)
    }
}
